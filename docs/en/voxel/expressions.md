# Expressions
An **expression** in Voxel is any code that — when executed — produces a value.

An expression can be or contain:

* Variable and identifier names (such as `score`)
* Value literals (such as `7`, `"Charlie"`, `[1, 2, 3]`, `{votes: 6}`)
* Atoms (such as `true`, `false`, `null`)
* Function or method calls (such as `openDoor()`)
* Accessor expressions (such as `list[2]`, `object.prop`)
* Function and class declarations

Individual expressions can be subunits of larger expressions by either being passed as an argument to a function or method, or by being operands joined by operators.

## Operators
Voxel has a variety of **operators** that can be used to compute a value from a number of operands. Operators are evaluated in the order of their precedence as opposed to lineraly.

Some operators take one operand (such as NOT, `!`), and these are known as **unary operators** which prefix their operands. Operators that take multiple operands are known as **binary operators**.

Brackets (`(` and `)`) can surround an expression to clarify the order of evaluation where the operator precedence order would otherwise cause a different result to be produced.

Here is a list of operators that can be used in Voxel, from highest precedence to lowest:

| Syntax | Meaning | Assignment syntax | Notes |
|-|-|-|-|
| `++` (unary) | Increment |  | 1 |
| `--` (unary) | Decrement |  | 1 |
| `-` (unary) | Negate |  |  |
| `!` (unary) | Logical NOT |  |  |
| `&` (unary) | Copy (shallow) |  |  |
| `*`, `/`, `%` | Multiplication, division, modulo | `*=`, `/=`, `%=` | 2 |
| `+`, `-` | Addition, subtraction | `+=`, `-=` | 2 |
| `==`, `!=`, `===`, `!==`, `<`, `<=`, `>`, `>=` | Equal to, not equal to, identical to, not identical to, strictly less than, less than or equal to, strightly greater than, strictly greater than or equal to |  | 2, 3 |
| `is`, `inherits` | Is instance of, Inherits |  | 2, 3 |
| `&&&` | Logical eager AND | `&&&=` |  |
| `\|\|\|` | Logical eager OR | `\|\|\|=` |  |
| `&&` | Logical short-circuiting AND | `&&=` | 4 |
| `\|\|` | Logical short-circuiting OR | `\|\|=` | 4 |
| `??` | Nullish coalescing | `??=` | 4 |

1. The increment and decrement operators will mutate the stored value that has been referenced. This means that all other references to the same value through assignment will also change (this is to reduce the complexity of generated bytecode). This behaviour can be inhibited by using the copy operator (`&`) when assigning to a variable that will be incremented or decremented or by using the addition or subtraction assignment operator (`+=` or `-=`). When these unary operators are used as a prefix, the expression will evaluate to the final stored value; if used as a suffix, it will evaluate to the stored value prior to mutation.
2. Operators in the same row in the table share equal precedence; they are evaluated linearly when chained.
3. All binary operators except for these operators support usage as an assignment operator.
4. These operators are **short-circuiting**; their right-hand operand is not evaluated if the left-hand operand has determined the evaluation's result. All other operators are **eager** in evaluation, meaning that all operands are evaluated before the result is computed. Short-circuit operators are less space-efficient than eager operators in bytecode, but evaluating them is more efficient in some situations. Note that when used as assignment operators, the left-hand operand (in addition to any accessors, if present) may be evaluated up to two times as their current value must first be checked to determine whether to evaluate the right-hand operand (this is to reduce the complexity of generated bytecode). This can be prevented by using eager assignment operators, but additionally note that in the case of eager evaluation, the right-hand operand will always be evaluated regardless of the current value of the left-hand operand.

## Assignment operators
**Assignment operators** are operators that can be used to set the value of a variable or a value referenced in a list or object. Their left-hand operand must be a variable name (such as `score`) or expression that ends with an accessor (such as `list[2]` or `object.prop`). Their right-hand operand will then be used as the value to store. The full operator expression evaluates to the stored value.